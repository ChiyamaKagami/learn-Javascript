# 从输入URL到页面展示这中间发生了什么
## 过程
1. 用户输入
2. URL请求过程
    - **浏览器进程**通过`进程间通信(IPC)`将URL请求发送到**网络进程*
    - **网络进程**查找本地缓存是否缓存该资源
    - 如果没有命中缓存，**则进入网络请求流程**，进行DNS解析(如果是HTTPS还需要建立TLS连接)
    - 利用IP地址和服务器建立TCP连接
    - 浏览器构建请求行、请求头等信息并将该域名相关的Cookie等数据附加到请求头上，然后向服务器发送构建的请求信息。
    - 如果返回的状态码是301或者302则说明服务器需要浏览器重定向到其他URL。这时候**网络进程**会从响应头的`Location`字段读取重定向的地址，然后重新发起`HTTP`或者`HTTPS`请求。
    - 浏览器通过`Content-Type`判断返回是下载类型还是HTML页面`(text/html)`。
3. 准备渲染进程
    - 默认情况下，每个页面分配一个**渲染进程**。
    - 特殊情况，统一站点`(same-site)`则复用渲染进程
        > 同源(same-origin)和同站(same-site)概念不一样，简单来说就是相同协议和根域名
4. 提交文档
    > 这里文档是指URL请求的相应体数据
    - 浏览器进程发出"提交文档"的消息，渲染进程收到"提交文档"的消息后，会和网络进程建立传输数据的管道
    - 等文档数据传输完毕，渲染进程会返回"确认提交"的消息给浏览器进程
    - 浏览器进程在收到"确认提交"的消息后，会更新浏览器界面状态，包括安全状态、地址栏URL、前进后退的历史状态、更更新页面
    到这里一个完整的导航流程就完成了。
5. 渲染阶段
    - 解析HTML文件，构建DOM树
    - 样式计算
        1. 将CSS转换为浏览器能够理解的结构styleSheets(link引用外部/<style>/元素style)
        2. 转换样式表的属性值，使其标准化(color: red/em -> px...)
        3. 计算出DOM树中每个节点的具体样式(样式继承和层叠)
        > 层叠是CSS的一个基本特征，定义了如何合并来自多个源的属性值的算法
    - 布局阶段
        > 布局阶段完成两个任务：创建布局树和布局计算
        - 分层
            因为页面中有很多复杂的效果，例如一些复杂的3D变换、页面滚动、使用z-index做z轴排序，为了更加方便实现这些功能，渲染引擎需要为特定的节点生成专用的图层并对应生成一颗图层树(LayerTree)，最后图层叠加构成最终的页面图像
            > 1. 拥有层叠上下文属性的元素会被提升单独的一层(position:fixed/z-index/filter:blur/opacity:0.5)
            > 2. 裁剪(clip)也会创建图层
            > 例如overflow: auto，会对不可视范围进行裁剪，滚动条也会提升为单独的层
        - 图层绘制
        渲染引擎将每个图层的绘制才分成很多小的绘制指令并添加到绘制列表里，这些绘制指令就类似说在某个区域绘制黑色线之类的，一般一个元素需要多条绘制指令
        - 栅格化
        > 所谓栅格化就是将图块转为位图
        实际的绘制操作是由渲染引擎中的合成线程来完成的。通常一个页面很大，用户只能看到其中一部分，全部渲染产生太大开销，所以合成线程会将图层划分为图块，一般尺寸为256x256或者512x512。然后合成线程会按照视口附近的图块来优先生成位图。所有的图块栅格化都在线程池内执行的。通常来说栅格化过程都使用GPU来加速生成，那这个过程又叫快速栅格化，生成的位图存在GPU内存中，GPU操作运行在GPU进程，所以这里又涉及跨进程操作。
        - 合成和显示
        一旦所有图块都光栅化，合成线程就会生成一个绘制图块的命令"DrawQuad"提交到浏览器进程，浏览器进程接收后将页面内容绘制到内存中，最后再将内存中的位图数据显示在屏幕上

# 参考
[从输入URL到页面展示这中间发生了什么](https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA)