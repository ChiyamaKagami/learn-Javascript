# HTTP

## 状态码

- 1xx -> 信息性状态码 -> 接受的请求正在处理
- 2xx -> 成功状态码 -> 请求处理完毕
- 3xx -> 重定向状态码 -> 需要进行附加操作以完成请求
- 4xx -> 客户端错误状态码状态码 -> 服务器无法处理请求
- 5xx -> 服务器错误状态码 -> 服务器处理请求出错

---

- 200 成功
- 201 成功创建新资源的状态
- 204 服务器已满足请求，但不需要恢复
- 304 命中协商缓存
- 400 服务器由于客户端错误而无法理解或者请求处理
- 401 需要身份验证但失败或未提供身份
- 403 与401类似，一般是缺乏权限
- 404 服务器无法找到该资源
- 409 请求与资源当前状态冲突
- 410 请求资源不再可用
- 500 错误

## Method

| 方法    | 描述                                                  | 幂等 |
| ------- | ----------------------------------------------------- | ---- |
| GET     | 查询操作，对应数据库`select`操作                      | 是   |
| PUT     | 所有信息更新，对于数据库`update`                      | 是   |
| DELETE  | 更新操作，对于数据库`delete`操作                      | 是   |
| POST    | 新增操作，对应数据库`insert`操作                      | 否   |
| HEAD    | 用于返回一个资源对象的"元数据"，或者探测 API 是否健康 | 是   |
| PATCH   | 用于局部信息的更新，对应数据库`update操作`            | 否   |
| OPTIONS | 获取 API 相关信息                                     | 是   |

> 不要机械地通过数据库的 CRUD 来对应这些动词，很多时候，还是要分析一下业务语义。如登录接口应该是 POST(新增 session)，登出是 DELETE

> 幂等性: 就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用

## Content-Length

服务端告诉客户端 body 的大小，但是有时候服务端并不能准备提前告知 body 有多大。

1. 服务端需要先写 header 再写 body
2. body 动态生成，如果等生成完再写 header 会占用额外的开销

所以有三种情况去获取资源大小：

1. `服务器知道资源大小，直接通过Content-Length`
2. `回复报文的Header添加Transfer-Encoding: chunked`  
   表明分块传输，每一块都使用固定的格式，前面是块的大小，后面是数据；最后一块的大小为 0，此时客户端解析的时候需要去掉一些无用字段
3. `没有content-length、transfer-encoding `
   这种情况只能使用短连接，以连接结束来标示数据传输结束，当传输结束的时候就知道大小了。

## Content-Type

- form 表单
  1. application/x-www-form-urlencoded
     form 表单数据被编码为 key/value 格式发送到服务器(表单默认提交格式)
     ```
       Name=John+Smith&Age=23
     ```
  2. multipart/form-data
     需要在表单中进行文件上传，可能有批量上传，为了区分数据，用 Boundary 参数进行分割
  3. text/plain
     纯文本格式
- 其他
  - application/json
    返回 JSON 格式
    ```
      {"Name": "John Smith", "Age": 23}
    ```
  - text/x-json
    实验性，非官方 MIME 类型

## CORS-preflight

面对跨域的非简单请求(复杂请求)会发起预检，浏览器会先询问服务器(OPTION 请求)，当前域名是否在服务器许可名单前，以及可以使用哪些 HTTP 头信息字段，只有通过才会正式发起 AJAX 请求。

## Keep-alive

- `TCP(keepalive)`  
   TCP 层实现，称之 TCP 保活机制，意图是心跳、检测连接错误。
  > 原理就是通过计时器发送 TCP 探测包
- `HTTP(Keep-Alive)`  
  应用层实现，称之为 HTTP 长连接，意图是连接复用。
  > 原理就是 HTTP 服务器不会在每次响应后关闭 TCP 连接，而是等待一段时间，如果其他 HTTP 请求也可以通过，一段时间后，它无论如何都会关闭它。

> 这个维护是通过 HTTP 守护进程的 timeout，时间过期则关闭

    那HTTP的Keep-Alive基于TCP的keepalive吗？

    不需要，如果客户端发送请求，它将得到响应，如果客户端没有通过TCP发送任何请求(可能连接已死)，那么超时将关闭连接；客户端可以感知并在需要的时候重新建立另外一个TCP连接发送请求。

    我个人理解HTTP的Keep-Alive里把HTTP请求当作心跳包，所以不需要基于TCP的keepalive

## 长连接

- TCP 的长连接
  具备双端连续收发报文的能力；
- HTTP 的长连接
  开启 keep-alive 的 HTTP 连接也是一种长连接，但是由于协议本身的限制，服务端无法主动发起应用报文

## 队头阻塞(Head-Of-Line Blocking)(HOL)

- HTTP 队头阻塞
  - 0.9 版本，使用串行连接，需要等待上一个请求完成，才能执行下一个请求
  - 1.0 版本，使用并行连接，浏览器限制并行连接通常为 4 个，只能缓解队头阻塞
- TCP 队头阻塞
  TCP 收到数据之后不会直接发送，而是将数据切割成 MSS(Maximum Segment Size 最大报文长度)大小，由于 IP 层不保证数据的可靠性和有序性，所以接收端可能会先收到窗口末端的数据，这时候 TCP 是不会向上层应用交付数据的，必须等待前面的数据都接收，这就是 TCP 的队头阻塞。

## 简单请求/非简单请求(复杂请求)

- `简单请求`  
  普通 HTML Form 可以发出的请求(method 方法、enctype 编码)，且 Form 表单发出的请求不会触发同源策略，因为 submit 之后是没有返回的。  
  简单请求不发`preflight`不是不能兼容，而是兼容为前提下发`preflight`对绝大多数服务器应用来说没有意义，反而把问题搞复杂。
- `非简单请求`  
  除了简单请求就是非简单请求了，**需要注意跨域情况下会走`CORS-preflight机制`**

## 常见问题

- `一个 TCP 连接可以同时发送几个 HTTP 请求`
- `浏览器 HTTP 请求的并发性是如何体现的？并发请求的数量是否有限制？`

- `keep-alive和pipeling的区别？`
  - `keep-alive`  
    请求结束之后不断开连接，省去下次的三次握手四次挥手
  - `pipeling`  
    可以并行发出多个请求，不需要等待上个请求的返回，但是服务器响应必须按次序返回，所以导致 pipeling 没有什么浏览器使用

## 版本历史

| 传统 HTTP | HTTPS   | HTTP/2 | HTTP/3 |
| --------- | ------- | ------ | ------ |
| HTTP      | HTTP    | HTTP/2 | HTTP/2 |
| TCP       | SSL/TLS | TLS1.2 | QUIC   |
| IP        | TCP     | TCP    | UDP    |
| MAC       | IP      | IP     | IP     |
|           | MAC     | MAC    | MAC    |

### 0.9(1991)

只有 GET 请求，并且只能传输文本 html 格式，返回的内容是 ASCII 字符串流

### 1.0(1996)

#### `新增`

- 二进制文件传输(视频音频图片)
- 请求头/响应头信息(原来只需要传输数据)
- 状态码(status code)
- 多字符集支持
- 缓存(cache)
- 新增 POST 和 HEAD 等请求方法
- 非标准的长链接  
  请求头添加`Connection: keep-alive`，默认不开启
- 内容编码(content encoding)
- 多部分发送(multi-part type)

#### `局限`

- 连接无法复用
- 队头阻塞

### 1.1(1997)

#### 新增

- 管道机制(pipeling)
- 默认开启`keep-alive`
- 头信息`Content-Length`
- 更多的请求方式，如 PUT、PATCH、OPTIONS、DELETE 等
- 头信息 Host
- 支持断点续传
- 24 个错误状态响应码

#### 局限

- header 信息太大
- 客户端可以并行发送多个请求，但是服务器响应必须按次序返回，所以导致 pipeling 没有什么浏览器使用

### 2.0(2015)

基于 SPDY(发音同`speedy`)协议，主要解决 HTTP1.1 效率不高的问题。

#### 新增

- `二进制分帧`  
  将一个 TCP 连接分为若干个流(Stream)，每个流中可以传输若干消息(Message)，每个消息由若干最小的二进制帧(Frame)组成。每个用户的操作行为会分配一个流编号(Stream ID)，表明用户与服务端之间创建了一个 TCP 通道；  
  协议将每个请求分割为二进制的控制帧和数据帧。

  | HTTP1.x   | HTTP2.0   |
  | --------- | --------- |
  | StartLine | Length    |
  | Header    | Type      |
  | Body      | Flags     |
  |           | Stream ID |
  |           | Payload   |

- `多路复用(Multiplexing)`  
  比起 HTTP1.1，HTTP2 的多路复用不需要先入先出
- `请求头压缩`  
  HPACK 算法基于霍夫曼编码
- `请求优先级`  
  设置 Stream 改变其优先级(Priority)和依赖(Dependency)，优先级高的会有限返回，stream 还能依赖其他 sub streams。两个属性都是可以动态调整的。
- `服务端推送(Server Push)`  
  即服务端向客户端发送比客户端请求更多的数据，允许服务器直接提供浏览器渲染页面所需资源，而不需要浏览器收到、解析页面之后再发起一轮请求

### 3.0(2018)

基于 UDP 的 QUIC(Quick UDP Internet Connection)协议，主要解决 HTTP2.0 中存在的 TCP 拥塞控制影响导致少量的丢包就会导致整个 TCP 连接的所有流被阻塞。

- 相比 HTTP2 优势
  - `减少TCP三次握手及TLS握手时间`
  - `改进的拥塞控制`  
    QUIC 协议当前默认使用 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC
  - `避免队头阻塞的多路复用`
  - `连接迁移`  
    网络环境变更，如 WIFI 切蜂窝
  - `前向冗余纠错`  
    重要的包比如握手信息丢失的时候能够根据冗余信息还原握手信息
  - `可拔插`
    1. 应用程序层就能实现不同的拥塞控制算法，不需要操作系统和内核支持。因为传统的 TCP 拥塞控制必须端到端的网络协议栈支持才行，在网络爆炸式增长的今天无法满足。
    2. 即使是单个应用程序的不同连接也能支持配置不同的拥塞控制，可以为各个用户提供不同但是又更加精准的拥塞控制。
    3. 应用程序不需要停机进行升级就能实现拥塞控制的变更，只需要服务端修改配置后 reload 就能进行切换 -` 单调递增的Packet Number`  
       QUIC 使用 Packet Number 代替 TCP 的 sequence number，并且每个 Packet Number 严格递增，重传的 Packet N 的 number 已经不是 N，而是比 N 大的值。  
       TCP 在上述情况下会重传一个 sequence number 一致的数据，当收到两个 sequence number 一致的数据时无法判断时原来的数据还是重传的数据。

## HTTPS

### 概念

#### 对称加密

指加密和解密都是同一个密钥。

#### 非对称加密

指加密和解密不是同一个密钥。  
其中公钥进行加密且可以公开,并给别人进行加密；私钥解密，私钥永远在自己手上。

#### 数字证书

网站在使用 HTTPS 前需要向 CA 机构申领一份数字证书，证书里包含证书持有者信息、公钥信息。  
这时候服务器把证书传输给浏览器，浏览器从证书里获取公钥即可。

#### 数字签名

非对称加密的私钥加上摘要算法(MD5/SHA-1/SHA-2)实现“身份认证”和“不可否认”。  
签名和公钥一样完全公开。签名只能用私钥对应的公钥进行解密，拿到摘要后对比原文验证完整性，就能证明消息来源正确。

### SSL/TLS

SSL 即安全套接层(Secure Sockets layer)，在 OSI 模型处第 5 层(会话层)。

> 发展到 v3 版本的时候已经证明是一个非常稳定的安全通信协议，于是互联网工程组 IETF 在 1999 年改名为 TLS(传输层安全，Transport Layer Security)，正式标准化，所以 TLS1.0 实际就是 SSLv3.1。

TLS 基于混合加密，在通信开始的时候使用非对称加密，解决密钥交换问题。对方拿到密文之后用私钥解密，取出会话密钥，这样双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全部使用对称加密。

> 简单理解：通信双方通过非对称加密协商出一个用于对称加密的密钥

#### 版本

- v1.1(2006)
- v1.2(2008)
- v1.3(2018)

#### 构成

- 记录协议(Record Protocol)
  规定 TLS 收发数据的基本单位：记录(record)
- 警报协议(Alert Protocol)
- 握手协议(Handshake Protocol)
- 变更密码规范协议(Change Cipher Spec Protocol)

## RTT

> RTT(Round Trip Time): 往返时延，数据包从发出去到收到对应 ACK 的时间。

- tcp: 1.5RTT
- tsl/ssl: 1.5RTT

# 参考

[合并 HTTP 请求是否真的有意义？](https://www.zhihu.com/question/34401250/answer/58746920)

[彻底理解 CORS 跨域原理](https://www.cnblogs.com/qiujianmei/p/11649905.html)
