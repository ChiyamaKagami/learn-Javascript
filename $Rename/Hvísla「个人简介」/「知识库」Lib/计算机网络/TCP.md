# TCP

面向连接、可靠的、字节流的基于传输层网络协议

- 可靠
  - 有状态
    在一次 TCP 连接中，每一次数据交换都和上一次紧密相关的，TCP 报文存在 ACK 字段用于确认上次接收的报文，并且 TCP 在建立连接时交换了很多连接配置信息（收/发缓存大小、报文序号）
    > HTTP 虽然基于 TCP 但是 HTTP 是无状态 | [详情](http://xieli.leanote.com/post/6.HTTP%E6%98%AF%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%9F?from=from_parent_mindnote)
  - 可控制
    当丢包或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制发送速度或者重发，对于数据报丢失的情况，TCP 提供重传机制

## 头格式

## 状态机

## `标志位`
- `number`
  - seq(Sequence number)
  标识从TCP源端向目的端发送的字节流
  - ack(Acknowledgement number)
  只有标志位ACK=1的时候，确认序号字段才有效，ack=seq+1
- `flags`
  - URG(Urgent)
  紧急位，URG=1表示紧急数据
  - `ACK(Acknowledgement)`
  确认位，ACK=1表示序号有效
  - PSH(Push)
  推送位，PSH=1，表示尽快把数据交付给应用层
  - RST(Rest)
  重置位，RST=1，表示重新建立连接
  - `SYN(Synchronization)`
  同步位，SYN=1，表示发起新连接
  - `FIN(Finish)`
  终止位，FIN=1，表示释放连接
## 三次握手

### `第一次握手(客户端向服务端发起连接请求)`

> 客户端：未知  
> 服务端：未知

    客户端随机生成一个起始序列号ISN，假设为x；则客户端发送的报文包含SYN标志位(SYN=1)，序列号seq=x

### `第二次握手(服务端收到客户端发送的报文并回复)`

> 客户端：未知  
> 服务端：已知自身接收能力正常；客户端发送能力正常

    服务端通过 SYN=1 了解这个是连接请求，于是将起始序列号 x 存起来，并随机生成一个服务端的起始序列号，假设为 y；服务端回复一段报文：SYN 和 ACK 标志(SYN=1，ACK=1)，序列号 seq=y、确认号 ack=x+1(将客户端起始序列号 + 1)

### `第三次握手(客户端收到服务端回复)`

> 客户端：已知自身发送/接收能力正常；服务端发送/接收能力正常  
> 服务端：已知自身发送/接收能力正常；客户端发送/接收能力正常

    1. 客户端通过ACK=1且ack=x+1了解到服务端收到序列号为x的报文
    2. 并且通过SYN=1了解到服务端同意了这次连接，所以先把服务端的序列号y存起来
    3. 回复服务端：ACK标志位(ACK=1)、ack=y+1(服务端起始序列号 + 1)、seq=x+1(第一次握手占据一个序列号，所以seq从x+1开始，注意不携带数据的ACK报文不占据序列号，所以后续第一次正式发送数据时seq还是x+1)。

服务端收到报文后发现 ACK=1 且 ack=y+1，就知道客户端收到序列号为 y 的报文，这样就通过 TCP 建立起客户端和服务端的连接。

### 常见问题

- `为什么TCP连接的时候是3次，关闭确是4次`  
  因为只有客户端和服务端之间没有数据传输才能断开 TCP 连接，这里要确认服务端是否还有数据发送需要多一次。
- `为什么客户端发出第四次挥手的确认报文之后还需要等2MSL的时间才能释放TCP连接`  
  考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认 ack 报文就会重发第三次挥手的报文。报文一来一回最长时间即 2MSL。
  > MSL: 报文最大生存时间(Maximum Segment Lifetime)
- `如果已经建立了连接，但是客户端突然出现故障怎么办？`  
  TCP 设置有保活计时器，如果客户端出现故障，服务器不能一直等下去。  
  服务端在每次收到客户端的请求之后都会重新复位这个计时器，时间一般设置为 2 小时，若过了这个时间之后仍未收到客户端任何数据，服务端就会发送一个探测报文段，以后每隔 75 秒发送一次，持续发送 10 个后仍然没有反应就会认为客户端出现故障，关闭连接。

## 四次挥手

客户端初始化的序列号 ISA=100，服务端初始化的序列号为 300。TCP 连接成功后客户端发送了 1000 个字节的数据，服务端在客户端发 FIN 报文之前总共回复了 2000 个字节的数据。

### `第一次挥手`

    客户端释放连接报文：FIN标志位(FIN=1)、序列号seq=1101（100 + 1(建立连接占用序列号) + 1000）。
    FIN报文即使不携带数据也要占据一个序列号。
    客户端发送FIN报文之后不能发数据，但是可以正常接收数据。

### `第二次挥手`

    服务端收到客户端发送的FIN报文之后进行回复：确认报文中：ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101 + 1)、序列号seq=2300(300 + 2000)。
    此时服务端处于关闭等待状态，等待服务端的数据发送完毕，才给客户端发送FIN报文。

### `第三次挥手`

    服务端将最后数据（比如50字节）发送完毕后就向客户端发送连接释放报文：FIN和ACK标志位(FIN=1，ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350（2300 + 50）。

### `第四次挥手`

    客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。
    注意客户端发出确认报文后不是立马释放TCP连接，而是经过2MSL(最长报文段寿命的两倍时长)后才会释放TCP连接。而服务端结束TCP连接的时间比客户端早一些。

## 滑动窗口

## 重传机制

## 慢启动

## SACK

## 重复收到数据的问题(Duplicate SACK)
