# 事件循环

首先从为什么需要事件循环开始吧，JavaScript 是一门单线程语言，这就说明同一时间内只能运行一个任务。那按照这样的话如果有一个任务需要 30 秒，我们就需要等待 30 秒之后才能继续运行其他任务。那浏览器就提供了一些 JavaScript 引擎自身不具备的特性：Web API，这里面包括了 DOM API、setTimeout、HTTP 请求等，可以帮助处理异步(async)、非阻塞(non-blocking)行为的操作。

那还要先说下调用栈，当我们调用这个函数的时候，这个函数就会被添加到调用栈里，本质是一个栈结构，意味着 FILO(First In, Last Out)，当函数返回值之后，就会从栈中弹出。

那当执行到 setTimeout 这类 Web API 代码的时候，就会将 setTimeout 里面的回调函数添加 Web API 中执行，这时候并不会立即添加到调用栈，而是传递到一个队列里。这时候就轮到事件循环工作了，事件循环的功能就是连接刚刚说这个队列喝调用栈。当调用栈是空的时候，就说明之前调用的函数已经返回了值，并且从栈中弹出，那么这个时候队列中的第一个函数就会被添加到调用栈里。

那刚刚说的其实都是从一个宏观的角度去看待的，我们一般的话还将队列里的任务细分出：微任务、宏任务

- 宏任务
  - <script>
  - setTimeout
  - setInterval
  - setImmediate
  - I/O
  - UI Event
  - requestAnimationFrame
- 微任务
  - Promise.then()/resolve()
  - process.nextTick
  - MutaionObserver
这两种任务之间主要是执行优先级不一样，刚刚说到任务会放到队列里面，其实是宏任务对应宏任务队列，微任务对应微任务队列。当执行栈为空的时候，主线程会查看宏任务队列是否有事件存在，如果存在则将最新的宏任务添加到执行栈，在这个宏任务的执行过程中如果遇到微任务，就会将其添加到微任务队列中，当这个宏任务执行完之后会依次执行微任务队列。并且在宏任务执行完毕之后会检查渲染，然后GUI线程接管渲染来实现重绘和回流。当渲染完毕之后JS线程继续接管，开始继续从事件队列取最新的宏任务执行。
