# 变量

## 引用

**引用(reference)**为对象起另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名。

```
int ival = 1024;
int ival2 = 1024;
int &refVal = ival;
int fakeVal = ival;
int &refVal2 = ival2;
std::cout << refVal << std::endl; // -> 1024
std::cout << fakeVal << std::endl; // -> 1024
ival = ival + 100;
    std::cout << ival << std::endl; // -> 1124
std::cout << fakeVal << std::endl; // -> 1024
std::cout << refVal << std::endl; // -> 1124
std::cout << refVal2 << std::endl; // -> 1024
```

> 指针可以为空，引用不能为空

```
    int i, &ri = i;
    i = 5; ri = 10;
    std::cout << i << " " << ri << std::endl; // ->
```

## 指针

指针(pointer)是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。  
**指针本身就是一个对象**，允许对指针的赋值和拷贝，在指针生命周期内可以先后指向几个不同的对象。  
指针无须定义时赋初值。

定义指针类型的方法将声明符写成`*d`的形式。如果一条语句中定义多个指针，每个变量都需要有符号`*`

```
int *ip1, *ip2;
double dp, *dp2;
```

### 获取对象的指针

```
int ival = 42;
int *p = &ival; // p存放变量ival的地址，或者说p指向变量`ival`的指针
std::cout << ival << "-" << *p << std::endl; // ival等于*p
std::cout << p << "-" << &ival << std::endl; // p等于&ival
```
### 指针值(即地址)
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除上述情况下意外的值

### 利用指针访问对象
使用`解引用符*`来访问对象
```
int ival = 42;
int *p = &ival;
cout << *p;
```
**对解引用的结果赋值，实际上就是给指针所指的对象赋值**
```
*p = 0;
cout << *p; // -> 0
```

### 空指针
生成空指针的方法：
1. `int *p1 = nullptr`
等价于`int *p1 = 0;`，使用字面值`nullptr`初始化指针。
2. `int *p2 = 0;`
可以通过指针初始化为字面值0来生成空指针。
3. `int *p3 = NULL;`
`NULL`是预处理变量(preprocessor variable)，需要在头文件`#include cstdlib`，该值为0。