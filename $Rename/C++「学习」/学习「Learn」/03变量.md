# 变量

## 引用

**引用(reference)**为对象起另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中`d`是声明的变量名。

```
int ival = 1024;
int ival2 = 1024;
int &refVal = ival;
int fakeVal = ival;
int &refVal2 = ival2;
std::cout << refVal << std::endl; // -> 1024
std::cout << fakeVal << std::endl; // -> 1024
ival = ival + 100;
    std::cout << ival << std::endl; // -> 1124
std::cout << fakeVal << std::endl; // -> 1024
std::cout << refVal << std::endl; // -> 1124
std::cout << refVal2 << std::endl; // -> 1024
```

> 指针可以为空，引用不能为空

```
    int i, &ri = i;
    i = 5; ri = 10;
    std::cout << i << " " << ri << std::endl; // ->
```

## 指针

指针(pointer)是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。  
**指针本身就是一个对象**，允许对指针的赋值和拷贝，在指针生命周期内可以先后指向几个不同的对象。  
指针无须定义时赋初值。

定义指针类型的方法将声明符写成`*d`的形式。如果一条语句中定义多个指针，每个变量都需要有符号`*`

```
int *ip1, *ip2;
double dp, *dp2;
```

### 获取对象的指针

```
int ival = 42;
int *p = &ival; // p存放变量ival的地址，或者说p指向变量`ival`的指针
std::cout << ival << "-" << *p << std::endl; // ival等于*p
std::cout << p << "-" << &ival << std::endl; // p等于&ival
```

### 指针值(即地址)

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除上述情况下意外的值

### 利用指针访问对象

使用`解引用符*`来访问对象

```
int ival = 42;
int *p = &ival;
cout << *p;
```

**对解引用的结果赋值，实际上就是给指针所指的对象赋值**

```
*p = 0;
cout << *p; // -> 0
```

### 空指针

生成空指针的方法：

1. `int *p1 = nullptr`
   等价于`int *p1 = 0;`，使用字面值`nullptr`初始化指针。
2. `int *p2 = 0;`
   可以通过指针初始化为字面值 0 来生成空指针。
3. `int *p3 = NULL;`
   `NULL`是预处理变量(preprocessor variable)，需要在头文件`#include cstdlib`，该值为 0。

### 符号多重含义

```
int i = 42;
int &r = i;           // &紧随类型名出现，因此是声明的一部分，r是一个引用
int *p;               // *紧随类型名出现，因此是声明的一部分，p是一个指针
p = &i;               // &出现在表达式中，是一个取地址符
*p = i;               // *出现在表达式中，是一个解引用符
int &r2 = *p;         // &是声明的一部分，*是一个解引用符
```

### void*指针
特殊的指针类型，用于存放任意对象的地址。
1. 和其他指针比较
2. 作为函数的输入或输出
3. 赋给另外一个void*指针。

## 总结
- 引用和指针的区别
> 引用是另一个对象的别名，而指针本身就是一个对象。 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。